<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="reset.css">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="print.css" media="print">
  <script src="toggle.js"></script>
  <title>Metronome</title>
  <style>

    html,
    body {
      height: 100%;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #playerWrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      margin: auto;
      max-width: 300px;
    }

    #chimeIntervalControls,
    #metronomeControls,
    #chimeControls {
      display: flex;
      flex-direction: row;
      justify-content: flex-start;
      align-items: center;
      gap: 0.5rem;
      width: 100%;
      line-height: normal;
    }

    #metronomeControls {
      font-size: 2.5rem;
    }

    #chimeControls,
    #chimeIntervalControls {
      font-size: 1.2rem;
    }

    #toggleButton {
      width: 1.5em;
      height: 1.5em;
      cursor: pointer;
      border: none;
      background: none;
      outline: none;
    }

    #testChimeButton {
      width: 30px;
      height: 30px;
      cursor: pointer;
      border: none;
      background: none;
      outline: none;
    }

    #chimeIntervalLabel {
      width: 30px;
      height: 30px;
      cursor: pointer;
      border: none;
      background: none;
      outline: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #chimeInterval,
    #chimeTone {
      width: 100%;
    }

    .icon {
      width: 100%;
      height: 100%;
    }

  </style>
</head>

<body>
<header>
  <input id="light-mode" class="toggle visually-hidden" type="checkbox">
  <label for="light-mode">
    <svg class="dark" width="22" height="22">
      <title>Bright light</title>
      <path fill="currentColor"
        d="M10.82 4.2c.46 0 .84-.38.84-.85v-2.1a.85.85 0 0 0-.84-.85.85.85 0 0 0-.85.85v2.1c0 .47.39.85.85.85m4.79 2c.33.32.87.33 1.2 0l1.5-1.5a.87.87 0 0 0 0-1.2.85.85 0 0 0-1.2 0L15.61 5a.85.85 0 0 0 0 1.2m1.98 4.8c0 .45.4.83.85.83h2.1c.46 0 .84-.38.84-.83a.85.85 0 0 0-.84-.85h-2.1c-.46 0-.85.39-.85.85m-1.98 4.79a.85.85 0 0 0 0 1.2l1.5 1.5c.33.33.87.3 1.2 0a.86.86 0 0 0 0-1.2l-1.5-1.5a.86.86 0 0 0-1.2 0m-4.79 2a.85.85 0 0 0-.85.84v2.11c0 .46.39.84.85.84s.84-.38.84-.84v-2.1a.85.85 0 0 0-.84-.85m-4.8-2a.9.9 0 0 0-1.2 0l-1.49 1.5a.86.86 0 0 0 0 1.19c.32.3.87.33 1.2 0l1.49-1.5a.86.86 0 0 0 0-1.19m-1.97-4.8c0-.45-.4-.84-.85-.84H1.1c-.46 0-.84.39-.84.85s.38.83.84.83h2.1c.46 0 .85-.38.85-.83M6.02 6.2a.86.86 0 0 0 0-1.2L4.55 3.5a.86.86 0 0 0-1.2 0 .86.86 0 0 0 0 1.2l1.49 1.5c.32.32.86.32 1.19 0M10.81 15.97a4.97 4.97 0 1 0 0-9.95 4.97 4.97 0 0 0 0 9.95" />
    </svg>
    <svg class="light" width="22" height="22">
      <title>Low light</title>
      <path fill="currentColor"
        d="M16.34 14.48c-5.29 0-8.67-3.3-8.67-8.6 0-1.21.27-2.69.62-3.5q.12-.33.1-.46c0-.25-.19-.54-.58-.54-.1 0-.34.02-.56.1-3.6 1.44-6.02 5.23-6.02 9.2a10.1 10.1 0 0 0 10.1 10.09c4.2 0 7.73-2.55 8.97-5.71.09-.24.1-.48.1-.57 0-.37-.28-.6-.56-.6-.12 0-.23.02-.42.08-.76.25-1.88.51-3.08.51" />
    </svg>
  </label>
</header>
  <div id="playerWrapper">
    <audio id="tickTone" src="freesound.org-692819-woodblock.mp3"></audio>

    <div id="metronomeControls">
      <button id="toggleButton" aria-label="Play">
        <svg id="playIcon" class="icon" viewBox="0 0 15 15" fill="none"
          xmlns="http://www.w3.org/2000/svg">
          <g stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
            <path
              d="M7.84729 14.25C11.4371 14.25 14.3473 11.3399 14.3473 7.75C14.3473 4.16015 11.4371 1.25 7.84729 1.25C4.25744 1.25 1.34729 4.16015 1.34729 7.75C1.34729 11.3399 4.25744 14.25 7.84729 14.25Z" />
            <path d="M6.34729 5.25L10.3473 7.75L6.34729 10.25V5.25Z" />
          </g>
        </svg>
        <svg id="stopIcon"  class="icon" viewBox="0 0 15 15" fill="none"
          xmlns="http://www.w3.org/2000/svg" style="display: none;">
          <g stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
            <path
              d="M7.84729 14.25C11.4371 14.25 14.3473 11.3399 14.3473 7.75C14.3473 4.16015 11.4371 1.25 7.84729 1.25C4.25744 1.25 1.34729 4.16015 1.34729 7.75C1.34729 11.3399 4.25744 14.25 7.84729 14.25Z" />
            <path d="M6.34729 5.25V10.25" />
            <path d="M9.34729 5.25V10.25" />
          </g>
        </svg>
      </button>

      <!-- Timer Display -->
      <div id="timer">00:00</div>
    </div>

    <div id="chimeControls">
      <button id="testChimeButton" aria-label="Test Chime">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 13.25h2M11 5.75a4 4 0 1 0-8 0v3.5a1.5 1.5 0 0 1-1.5 1.5h11a1.5 1.5 0 0 1-1.5-1.5zM.5 5.62A6 6 0 0 1 3 .75M13.5 5.62A6 6 0 0 0 11 .75"/></svg>
      </button>
      <!-- Chime Tone Dropdown -->
      <label class="visually-hidden" for="chimeTone">Tone</label>
      <select id="chimeTone">
        <option value="freesound.org-390543-bell-mid.mp3">bell</option>
        <option value="freesound.org-347379-bell-high.mp3">chime</option>
        <option value="freesound.org-240934-bell-low.mp3">gong</option>
      </select>
    </div>

    <div id="chimeIntervalControls">
      <!-- Chime Interval Dropdown -->
      <label id="chimeIntervalLabel" for="chimeInterval">
        <span class="visually-hidden">Interval</span>
        <svg viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
          <g stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
            <path
              d="M7 13.5C10.0376 13.5 12.5 11.0376 12.5 8C12.5 4.96243 10.0376 2.5 7 2.5C3.96243 2.5 1.5 4.96243 1.5 8C1.5 11.0376 3.96243 13.5 7 13.5Z" />
            <path d="M0.5 2.5C1.20228 1.68425 2.04999 1.00608 3 0.5" />
            <path d="M13.5 2.5C12.7977 1.68425 11.95 1.00608 11 0.5" />
            <path d="M7 5V8H9.5" />
          </g>
        </svg>
      </label>
      <select id="chimeInterval">
        <option value="0">off</option>
        <option value="0.5">every 30 seconds</option>
        <option value="1">every 1 minute</option>
        <option value="2">every 2 minutes</option>
        <option value="5">every 5 minutes</option>
        <option value="10">every 10 minutes</option>
        <option value="15">every 15 minutes</option>
        <option value="20">every 20 minutes</option>
        <option value="30">every 30 minutes</option>
        <option value="45">every 45 minutes</option>
        <option value="60">every 60 minutes</option>
      </select>
    </div>
  </div>
  <script src="unmute.min.js"></script>
  <script>
    const tickTone = document.getElementById("tickTone");
    const toggleButton = document.getElementById("toggleButton");
    const testChimeButton = document.getElementById("testChimeButton");
    const playIcon = document.getElementById("playIcon");
    const stopIcon = document.getElementById("stopIcon");
    const chimeIntervalSelect = document.getElementById("chimeInterval");
    const chimeToneSelect = document.getElementById("chimeTone");
    const timerDisplay = document.getElementById("timer");

    let metronomeId = null;
    let timerId = null;
    const tickIntervalMs = 1000; // 1 second (60 BPM).
    let chimeIntervalMs = parseFloat(chimeIntervalSelect.value) * 60000;

    let secondsElapsed = 0;
    let nextChimeAt = chimeIntervalMs / 1000; // Next chime time in seconds.
    let nextTickTime = 0;

    // Storage for both raw and decoded audio buffers.
    let rawBuffers = {};
    let audioBuffers = {};

    // Fetch an audio file and store its array buffer.
    async function fetchAudioFile(url) {
      if (rawBuffers[url]) {
        return rawBuffers[url];
      }
      try {
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        rawBuffers[url] = arrayBuffer;
        return arrayBuffer;
      } catch (error) {
        console.error(`Failed to fetch audio file ${url}:`, error);
        throw error;
      }
    }

    // Get the specified audio buffer.
    async function getAudioBuffer(url) {
      if (audioBuffers[url]) {
        return audioBuffers[url];
      }
      try {
        let arrayBuffer = rawBuffers[url] || await fetchAudioFile(url);
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        audioBuffers[url] = audioBuffer;
        return audioBuffer;
      } catch (error) {
        console.error(`Failed to decode audio data for ${url}:`, error);
        throw error;
      }
    }

    // Pre-fetch audio files on page load.
    fetchAudioFile(tickTone.src);
    fetchAudioFile(chimeToneSelect.value);

    // Initialize Web Audio API context.
    // This cannot be done on page load because of browser security policies,
    // so it is done upo the first user interaction, i.e. when the metronome
    // is started or the chime is tested.
    let audioContext = null;
    async function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }

      // Preload audio buffers.
      await getAudioBuffer(tickTone.src);
      await getAudioBuffer(chimeToneSelect.value);

      // Unmute the audio context.
      let allowBackgroundPlayback = true;
      let forceIOSBehavior = false;
      unmute(audioContext, allowBackgroundPlayback, forceIOSBehavior);
    }

    // Precise sound scheduling using Web Audio API.
    function scheduleSound(buffer, time) {
      const source = audioContext.createBufferSource();
      source.buffer = buffer;
      const volume = audioContext.createGain();
      source.connect(volume);
      volume.connect(audioContext.destination);
      const nearestSecond = Math.ceil(time);

      volume.gain.value = 0.25;
      source.start(nearestSecond);
    }

    // Start the metronome.
    async function startMetronome() {
      await initAudio();

      const tickBuffer = await getAudioBuffer(tickTone.src);

      nextTickTime = audioContext.currentTime;
      scheduleSound(tickBuffer, nextTickTime);

      metronomeId = setInterval(() => {
        scheduleSound(tickBuffer, audioContext.currentTime + 0.1);
      }, 1000);

      resetTimer();
      startTimer();
      toggleIcons(true);
    }

    // Stop the metronome and chime.
    function stopMetronome() {
      clearInterval(metronomeId);
      clearInterval(timerId);
      metronomeId = null;
      toggleIcons(false);
    }

    // Play selected chime tone on test button click.
    testChimeButton.addEventListener("click", async () => {
      await initAudio();
      const chimeBuffer = await getAudioBuffer(chimeToneSelect.value);
      const immediate = 0;
      scheduleSound(chimeBuffer, immediate);
    });

    // Toggle button icons and label.
    function toggleIcons(isPlaying) {
      if (isPlaying) {
        playIcon.style.display = "none";
        stopIcon.style.display = "inline";
        toggleButton.setAttribute("aria-label", "Stop");
      } else {
        playIcon.style.display = "inline";
        stopIcon.style.display = "none";
        toggleButton.setAttribute("aria-label", "Play");
      }
    }

    // Update chime interval on dropdown change.
    chimeIntervalSelect.addEventListener("change", () => {
      chimeIntervalMs = parseFloat(chimeIntervalSelect.value) * 60000;
      if (chimeIntervalMs > 0) {
        nextChimeAt = Math.ceil(secondsElapsed / (chimeIntervalMs / 1000)) * (chimeIntervalMs / 1000) - 1;
      } else {
        nextChimeAt = Infinity;
      }
    });

    // Update chime tone on dropdown change.
    chimeToneSelect.addEventListener("change", async () => {
      const response = await fetch(chimeToneSelect.value);
      const arrayBuffer = await response.arrayBuffer();
      audioBuffers.chime = await audioContext.decodeAudioData(arrayBuffer);
    });

    // Timer functions.
    function startTimer() {
      timerId = setInterval(() => {
        secondsElapsed++;
        updateTimerDisplay();
        checkChime();
      }, 1000);
    }

    function resetTimer() {
      clearInterval(timerId);
      secondsElapsed = 0;
      updateTimerDisplay();
      nextChimeAt = chimeIntervalMs > 0 ? chimeIntervalMs / 1000 : Infinity;
    }

    function updateTimerDisplay() {
      const minutes = Math.floor(secondsElapsed / 60);
      const seconds = secondsElapsed % 60;
      timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    // Check if it's time to play the chime.
    function checkChime() {
      if (chimeIntervalMs > 0 && secondsElapsed >= nextChimeAt) {
        scheduleSound(audioBuffers.chime, audioContext.currentTime);
        nextChimeAt += chimeIntervalMs / 1000;
      }
    }

    // Toggle metronome on button click.
    toggleButton.addEventListener("click", async () => {
      if (!audioContext) {
        await initAudio();
      }

      if (metronomeId === null) {
        startMetronome();
      } else {
        stopMetronome();
      }
    });

    // Clean up when page is closed.
    window.addEventListener("beforeunload", () => {
      if (metronomeId !== null) {
        clearInterval(metronomeId);
      }
      if (timerId !== null) {
        clearInterval(timerId);
      }
      if (audioContext) {
        audioContext.close();
      }
    });
  </script>
</body>

</html>
